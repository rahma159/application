#include "clientmanager.h"
#include "ui_clientmanager.h" // <<< Inclusion of the header generated by UIC

#include "chartdialog.h"
#include "gestionreclam.h" // Consider renaming this file too (e.g., claimmanagementdialog.h/cpp)
#include <QDebug>

// Includes necessary for functionality
#include <QMessageBox>
#include <QDateEdit>
#include <QFileDialog>
#include <QTextStream>
#include <QTableWidget>
#include <QTableWidgetItem>
#include <QHeaderView>
#include <QItemSelectionModel>
#include <QProcess> // Keep if used elsewhere, otherwise can be removed
#include <QStringConverter>
#include <QPalette>
#include <QSqlDatabase> // Added for CRUD
#include <QSqlQuery>    // Added for CRUD
#include <QSqlError>    // Added for CRUD
#include <QVariant>     // Added for CRUD
#include <QDateTime>    // Added for ID placeholder in GestionReclamDialog (not used here directly)


// Refactored constructor
ClientManager::ClientManager(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::ClientManager),
    m_selectedClientId(""), // Use new name from header
    m_alertThreshold(5)     // Use new name from header, ensure default matches UI if set there
{
    ui->setupUi(this);
    this->setMinimumSize(900, 700);
    qDebug() << "ClientManager: Taille minimale définie à 900x700.";

    setWindowTitle("Client Manager");
    setMinimumSize(800, 600);
    // Apply style (e.g., background image if you kept it)

    // --- Connections of signals to slots (using the ui pointer AND NEW SLOT NAMES) ---
    connect(ui->btnConsulter, &QPushButton::clicked, this, &ClientManager::viewClientClaims);       // Use new slot name
    connect(ui->btnSupprimer, &QPushButton::clicked, this, &ClientManager::deleteClient);           // Use new slot name
    connect(ui->btnRafraichir, &QPushButton::clicked, this, &ClientManager::loadInitialDataFromDB); // Refresh button reloads everything (function name kept)
    connect(ui->btnSeuilAlerte, &QPushButton::clicked, this, &ClientManager::changeAlertThreshold); // Use new slot name
    connect(ui->btnExporterCSV, &QPushButton::clicked, this, &ClientManager::exportToCSV);          // Use new slot name
    connect(ui->btnLancerAnalyse, &QPushButton::clicked, this, &ClientManager::runPredictiveAnalysis); // Use new slot name
    connect(ui->btnIncrementReclamation, &QPushButton::clicked, this, &ClientManager::incrementClaim);      // Use new slot name
    connect(ui->btnAfficherGraphique, &QPushButton::clicked, this, &ClientManager::showChart);           // Use new slot name
    connect(ui->tableClients->selectionModel(), &QItemSelectionModel::selectionChanged, this, &ClientManager::onTableSelectionChanged); // Name was already English
    connect(ui->dateEditDebut, &QDateEdit::dateChanged, this, &ClientManager::applyFilters);           // Use new slot name
    connect(ui->dateEditFin, &QDateEdit::dateChanged, this, &ClientManager::applyFilters);             // Use new slot name


    // --- UI Initialization ---
    ui->dateEditDebut->setDate(QDate::currentDate().addYears(-1));
    ui->dateEditFin->setDate(QDate::currentDate());
    ui->tableClients->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
    ui->tableClients->horizontalHeader()->setStretchLastSection(true);
    ui->spinSeuil->setValue(m_alertThreshold); // Initialize spinbox with the threshold (use new variable name)

    // --- Initial Data Loading ---
    // Note: loadInitialDataFromDB is called here, it calls refreshTable and applyFilters
    loadInitialDataFromDB();

    onTableSelectionChanged(); // Update initial state of buttons/fields


}

// Refactored destructor
ClientManager::~ClientManager()
{
    delete ui;
}
void ClientManager::refreshClientData()
{
    // Implementation to refresh data
    qDebug() << "Refreshing client data...";
    // Your data loading logic here
}
// --- Member function implementations ---

// Load Clients AND Claims from DB
void ClientManager::loadInitialDataFromDB() {
    qDebug() << "Loading initial data from the DB...";
    m_clients.clear();
    m_allClaims.clear(); // Use new variable name

    QSqlDatabase db = QSqlDatabase::database(); // Get default connection
    if (!db.isOpen()) {
        qWarning() << "loadInitialDataFromDB: DB connection is not open!";
        return;
    }

    // 1. Load Clients
    QSqlQuery clientQuery(db);
    // *** CORRECTED SQL QUERY ***
    // Use the actual column names from your Oracle table (likely NOM, PRENOM)
    QString selectQuery = "SELECT ID, NOM, PRENOM, DOMAINE, DATE_AJOUT FROM CLIENTS ORDER BY NOM, PRENOM";
    qDebug() << "Executing client query:" << selectQuery;

    if (!clientQuery.exec(selectQuery)) { // Execute the corrected query
        qWarning() << "Error loading clients:" << clientQuery.lastError().text(); // Log the specific error
    } else {
        while (clientQuery.next()) {
            ClientData client; // Use Client struct with new member names
            QString id = clientQuery.value(0).toString();
            // Assign values based on the order in the CORRECTED SELECT query
            client.lastName = clientQuery.value(1).toString();      // Column 1 is NOM (Last Name)
            client.firstName = clientQuery.value(2).toString();     // Column 2 is PRENOM (First Name)
            client.domain = clientQuery.value(3).toString();        // Column 3 is DOMAINE
            client.dateAdded = QDate::fromString(clientQuery.value(4).toString(), Qt::ISODate); // Column 4 is DATE_AJOUT
            client.claimCount = 0; // Initialize claim count (use new member name)
            m_clients.insert(id, client);
        }
        qDebug() << m_clients.count() << "clients loaded."; // Check if clients were actually loaded
    }

    // 2. Load ALL Claims
    QSqlQuery reclamQuery(db);
    // Assuming DB columns are ID, CLIENT_ID, DATE_RECLAMATION, DESCRIPTION, STATUT, IMPORTANCE
    // Adjust column names here if they differ in your actual DB schema
    if (!reclamQuery.exec("SELECT ID, CLIENT_ID, DATE_RECLAMATION, DESCRIPTION, STATUT, IMPORTANCE FROM RECLAMATIONS ORDER BY DATE_RECLAMATION DESC")) {
        qWarning() << "Error loading claims:" << reclamQuery.lastError().text();
    } else {
        while (reclamQuery.next()) {
            Reclamation reclam; // Assuming Reclamation struct exists
            reclam.id = reclamQuery.value(0).toString();
            reclam.clientId = reclamQuery.value(1).toString();
            QVariant dateVal = reclamQuery.value(2);
            if (dateVal.typeId() == QMetaType::QDateTime) { reclam.date = dateVal.toDateTime().date(); }
            else if (dateVal.typeId() == QMetaType::QDate) { reclam.date = dateVal.toDate(); }
            else { reclam.date = QDate::fromString(dateVal.toString(), Qt::ISODate); }
            reclam.description = reclamQuery.value(3).toString();
            reclam.statut = reclamQuery.value(4).toString();
            reclam.importance = reclamQuery.value(5).toString();
            m_allClaims.append(reclam); // Use new variable name
        }
        qDebug() << m_allClaims.count() << "claims loaded."; // Use new variable name
    }

    // 3. Update claim counts per client
    updateClientClaimCounts(); // Use new function name

    // 4. Update the interface
    refreshTable();  // Use new function name
    applyFilters();  // Use new function name
    checkAlerts();   // Use new function name
    qDebug() << "Initial data loaded and interface refreshed.";
}

// Count claims per client - Use new function name
void ClientManager::updateClientClaimCounts() {
    qDebug() << "Updating claim counters...";
    for (auto it = m_clients.begin(); it != m_clients.end(); ++it) {
        it.value().claimCount = 0; // Use new member name
    }
    for (const Reclamation& reclam : m_allClaims) { // Use new variable name
        if (m_clients.contains(reclam.clientId)) {
            m_clients[reclam.clientId].claimCount++; // Use new member name
        }
    }
    qDebug() << "Counters updated.";
}

// Show the chart - Use new function name
void ClientManager::showChart()
{
    ChartDialog chartDialog(this); // Assuming ChartDialog is okay or will be translated
    chartDialog.setWindowTitle("Clients per Domain");
    chartDialog.generateClientsPerDomainChart(m_clients); // Pass the map of clients
    chartDialog.exec();
}

// Launch analysis (open dialog with all claims) - Use new function name
void ClientManager::runPredictiveAnalysis()
{
    qDebug() << "Clicked 'Analyze Risks', opening Claim Management Dialog (all claims)...";
    GestionReclamationDialog dialog(this); // Consider renaming GestionReclamationDialog -> ClaimManagementDialog
    dialog.setWindowTitle("Claim Management (All)");
    dialog.setReclamationsData(m_allClaims); // Pass the complete list (Use new variable name)
    dialog.exec();
    qDebug() << "Claim Management Dialog (all) closed. Reloading data...";
    loadInitialDataFromDB(); // Reload after closing
}

// View claims for a specific client - Use new function name
void ClientManager::viewClientClaims()
{
    if (m_selectedClientId.isEmpty()) { // Use new variable name
        QMessageBox::warning(this, "No Selection", "Please select a client from the table first.");
        return;
    }
    qDebug() << "Claim consultation requested for client:" << m_selectedClientId; // Use new variable name

    QList<Reclamation> filteredClaims; // Renamed local variable for clarity
    for(const Reclamation& rec : m_allClaims) { // Use new variable name
        if (rec.clientId == m_selectedClientId) { // Use new variable name
            filteredClaims.append(rec);
        }
    }
    qDebug() << "Passing" << filteredClaims.count() << "filtered claims to the dialog.";

    GestionReclamationDialog dialog(this); // Consider renaming
    if (m_clients.contains(m_selectedClientId)) { // Use new variable name
        // Use client.firstName then client.lastName (new member names)
        dialog.setWindowTitle("Claims for " + m_clients.value(m_selectedClientId).firstName + " " + m_clients.value(m_selectedClientId).lastName + " (" + m_selectedClientId + ")");
    } else {
        dialog.setWindowTitle("Claims for " + m_selectedClientId); // Use new variable name
    }
    // Pass the filtered list AND the client ID for refresh context
    dialog.setReclamationsData(filteredClaims, m_selectedClientId); // Assuming setReclamationsData handles this // Use new variable name
    dialog.exec();
    qDebug() << "Claim Management Dialog (specific client) closed. Reloading data...";
    loadInitialDataFromDB(); // Reload after closing
}

// Display selected client's info in the fields - Use new function name
void ClientManager::displaySelectedClientInfo()
{
    if (!ui->tableClients->selectionModel()->hasSelection()) {
        clearInputFields(); // Uses ui-> already
        return;
    }
    int row = ui->tableClients->currentRow();
    if (row < 0 || row >= ui->tableClients->rowCount()) return;
    QTableWidgetItem *idItem = ui->tableClients->item(row, 0);
    if (!idItem) return;
    QString id = idItem->text();
    if (m_clients.contains(id)) {
        const ClientData& client = m_clients.value(id);
        m_selectedClientId = id; // Use new variable name
        ui->lineNom->setText(client.lastName);       // Use new member name (Assumes lineNom is for Last Name)
        ui->linePrenom->setText(client.firstName);   // Use new member name (Assumes linePrenom is for First Name)
        ui->lineDomaine->setText(client.domain);     // Use new member name (Assumes lineDomaine is for Domain)
        ui->labelEditID->setText(QString("Client ID: %1").arg(m_selectedClientId)); // Use new variable name
        ui->labelEditID->setVisible(true);
    } else {
        qWarning() << "Client ID" << id << "found in table but not in m_clients map!";
        clearInputFields(); // Uses ui-> already
    }
}

// Handle selection change in the table
void ClientManager::onTableSelectionChanged() // Name was already English
{
    bool hasSelection = ui->tableClients->selectionModel()->hasSelection();
    ui->btnSupprimer->setEnabled(hasSelection);
    ui->btnIncrementReclamation->setEnabled(hasSelection); // Keep or remove this button? Marked as less useful later.
    ui->btnConsulter->setEnabled(hasSelection);
    // Ensure labels in the .ui file are translated (e.g., labels for lineNom, linePrenom etc.)
    displaySelectedClientInfo(); // Use new function name to update the fields
}

// Clear client information fields
void ClientManager::clearInputFields() { // Name was already English
    ui->lineNom->clear();
    ui->linePrenom->clear();
    ui->lineDomaine->clear();
    ui->labelEditID->setVisible(false);
    m_selectedClientId = ""; // Use new variable name
}

// Delete selected client (DB + memory) - Use new function name
void ClientManager::deleteClient() {
    QList<QTableWidgetSelectionRange> selection = ui->tableClients->selectedRanges();
    if (selection.isEmpty()) { QMessageBox::warning(this, "No Selection", "Please select a client."); return; }
    int row = selection.first().topRow();
    QTableWidgetItem *idItem = ui->tableClients->item(row, 0);
    if (!idItem) return;
    QString id = idItem->text();
    if (!m_clients.contains(id)) { QMessageBox::warning(this, "Error", "Selected client not found."); return; }
    QString clientLastName = m_clients.value(id).lastName;       // Use new member name
    QString clientFirstName = m_clients.value(id).firstName; // Use new member name

    QMessageBox msgBox(QMessageBox::Question, "Confirmation",
                       QString("Delete client %1 (%2 %3)?\nThis will also delete ALL associated claims (if configured in DB)!").arg(id).arg(clientFirstName).arg(clientLastName), // Use new member names
                       QMessageBox::Yes | QMessageBox::No, this);
    msgBox.setDefaultButton(QMessageBox::No);

    if (msgBox.exec() == QMessageBox::Yes) {
        qDebug() << "Deletion request for client ID:" << id;
        QSqlQuery deleteQuery;
        // *** Ensure 'clients' and 'id' match your table/column names ***
        deleteQuery.prepare("DELETE FROM clients WHERE id = :id");
        deleteQuery.bindValue(":id", id);
        if (deleteQuery.exec()) {
            qDebug() << "Client ID:" << id << "deleted from DB.";
            QMessageBox::information(this, "Deletion Successful", QString("Client %1 (%2 %3) has been deleted.").arg(id).arg(clientFirstName).arg(clientLastName)); // Use new member names
            loadInitialDataFromDB(); // Reload everything
        } else {
            qWarning() << "ERROR deleting client ID:" << id << deleteQuery.lastError().text();
            QMessageBox::critical(this, "Database Error", "Could not delete client:\n" + deleteQuery.lastError().text());
        }
    }
}

// Generate unique ID (for client, if reactivated) - Use new function name
QString ClientManager::generateUniqueID() const {
    int idNum = 1;
    QString idStr;
    // This logic needs review if used, to check DB too
    do {
        idStr = QString("CLI%1").arg(idNum++, 3, 10, QChar('0'));
    } while (m_clients.contains(idStr)); // Check against memory map
    return idStr;
}

// Refresh the client table display - Use new function name
void ClientManager::refreshTable() {
    QString selectedId = m_selectedClientId; // Use new variable name
    int selectedRow = -1;
    ui->tableClients->setSortingEnabled(false);
    ui->tableClients->clearContents();
    ui->tableClients->setRowCount(0);
    // Ensure table headers (ID, Last Name, First Name, Domain, Claims) are set correctly in the .ui file
    int row = 0;
    // Use m_clients which was updated by loadInitialDataFromDB
    for (auto it = m_clients.constBegin(); it != m_clients.constEnd(); ++it) {
        ui->tableClients->insertRow(row);
        const ClientData& client = it.value();
        QString currentId = it.key();
        ui->tableClients->setItem(row, 0, new QTableWidgetItem(currentId));             // ID
        ui->tableClients->setItem(row, 1, new QTableWidgetItem(client.lastName));      // Use new member name
        ui->tableClients->setItem(row, 2, new QTableWidgetItem(client.firstName));     // Use new member name
        ui->tableClients->setItem(row, 3, new QTableWidgetItem(client.domain));        // Use new member name
        // Display calculated claimCount (Use new member name)
        QTableWidgetItem *claimsItem = new QTableWidgetItem(QString::number(client.claimCount)); // Use new member name
        claimsItem->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);
        ui->tableClients->setItem(row, 4, claimsItem);                                // Claim Count
        // Column 5 for Date Added if you uncommented it in the UI file:
        // ui->tableClients->setItem(row, 5, new QTableWidgetItem(client.dateAdded.toString(Qt::ISODate))); // Use new member name

        if(currentId == selectedId) { selectedRow = row; }
        row++;
    }
    ui->tableClients->setSortingEnabled(true);
    if (selectedRow != -1) {
        ui->tableClients->selectRow(selectedRow);
    } else {
        // If the old ID is no longer there (or never selected)
        if (!m_selectedClientId.isEmpty()) { // only if we lose an existing selection (Use new variable name)
            clearInputFields();
            onTableSelectionChanged(); // Update button state
        }
    }
}

// Apply date filters to the client table - Use new function name
void ClientManager::applyFilters() {
    QDate startDate = ui->dateEditDebut->date(); // Start Date
    QDate endDate = ui->dateEditFin->date();     // End Date
    bool selectionHidden = false;
    for (int i = 0; i < ui->tableClients->rowCount(); ++i) {
        QTableWidgetItem *idItem = ui->tableClients->item(i, 0);
        if (!idItem) continue;
        QString clientId = idItem->text();
        bool showRow = false;
        if (m_clients.contains(clientId)) {
            const ClientData& client = m_clients.value(clientId);
            // Assuming client.dateAdded is the relevant date for filtering clients (Use new member name)
            bool dateOk = (client.dateAdded >= startDate && client.dateAdded <= endDate);
            showRow = dateOk; // Filtering only by client added date
        }
        ui->tableClients->setRowHidden(i, !showRow);
        if (!m_selectedClientId.isEmpty() && clientId == m_selectedClientId && !showRow) { // Use new variable name
            selectionHidden = true;
        }
    }
    if (selectionHidden) {
        ui->tableClients->clearSelection();
        clearInputFields();
        onTableSelectionChanged();
    }
    checkAlerts(); // Use new function name - Re-apply coloring after filtering
}

// Export visible clients to CSV - Use new function name
void ClientManager::exportToCSV() {
    QString fileName = QFileDialog::getSaveFileName(this, "Export to CSV", "", "CSV Files (*.csv)");
    if (fileName.isEmpty()) return;
    QFile file(fileName);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream stream(&file);
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        stream.setEncoding(QStringConverter::Utf8);
#else
        stream.setCodec("UTF-8");
#endif \
    // Use English headers, matching table columns
        QStringList headers = {"ID", "Last Name", "First Name", "Domain", "Date Added", "Claims"};
        stream << "\"" + headers.join("\",\"") + "\"\n";
        for (int i = 0; i < ui->tableClients->rowCount(); ++i) {
            if (!ui->tableClients->isRowHidden(i)) {
                QTableWidgetItem* idItem = ui->tableClients->item(i, 0);
                QString id = idItem ? idItem->text() : "";
                if (m_clients.contains(id)) {
                    const ClientData& client = m_clients.value(id);
                    QStringList rowData;
                    rowData << id
                            << client.lastName      // Use new member name
                            << client.firstName     // Use new member name
                            << client.domain        // Use new member name
                            << client.dateAdded.toString("yyyy-MM-dd") // Use new member name
                            << QString::number(client.claimCount); // Use new member name
                    stream << "\"" + rowData.join("\",\"") + "\"\n";
                }
            }
        }
        file.close();
        QMessageBox::information(this, "Export CSV", "Data exported to " + fileName);
    } else {
        QMessageBox::critical(this, "Export Error", "Could not open file: " + file.errorString());
    }
}

// Placeholder for PPT export - Use new function name
void ClientManager::exportToPPT() {
    QMessageBox::information(this, "Export PPT", "Feature under development...");
}

// Increment claim (now less useful) - Use new function name
void ClientManager::incrementClaim() {
    if (m_selectedClientId.isEmpty()) { // Use new variable name
        QMessageBox::warning(this, "No Selection", "Please select a client.");
        return;
    }
    // Advise user on the proper way to add claims
    QMessageBox::information(this, "Action Unavailable", "Please use the 'View Claims' button and then 'Add Claim' within the claim details dialog to manage claims.");
}

// Check for alerts based on claimCount - Use new function name
void ClientManager::checkAlerts() {
    bool alertFoundInVisibleRows = false; // To potentially avoid multiple popups if filter applied
    for (int i = 0; i < ui->tableClients->rowCount(); ++i) {
        QTableWidgetItem *idItem = ui->tableClients->item(i, 0);
        if (!idItem) continue;
        QString clientId = idItem->text();
        if (m_clients.contains(clientId)) {
            const ClientData& client = m_clients.value(clientId);
            bool alert = (client.claimCount >= m_alertThreshold); // Use new member and variable names

            // Determine background color (handle alternating rows)
            QColor bgColor = Qt::white; // Default
            if (ui->tableClients->alternatingRowColors() && (i % 2 != 0)) {
                QPalette palette = this->palette();
                bgColor = palette.color(QPalette::AlternateBase);
                if (!bgColor.isValid() || bgColor == palette.color(QPalette::Base)) {
                    bgColor = QColor(240, 245, 255); // Example: Very light blue
                }
            }

            if (alert) {
                bgColor = QColor(255, 200, 200); // Light red for alert
                if (!ui->tableClients->isRowHidden(i) && !alertFoundInVisibleRows) {
                    // Use client.firstName then client.lastName (new member names)
                    showAlert(QString("⚠️ Alert: %1 %2 (%3) has %4 claim(s). Threshold is %5.") // Use new function name
                                  .arg(client.firstName).arg(client.lastName).arg(clientId).arg(client.claimCount).arg(m_alertThreshold)); // Use new member and variable names
                    // alertFoundInVisibleRows = true; // Uncomment to show only one alert popup per check
                }
            }

            // Apply background color to all cells in the row
            for (int col = 0; col < ui->tableClients->columnCount(); ++col) {
                QTableWidgetItem *item = ui->tableClients->item(i, col);
                if(!item) {
                    item = new QTableWidgetItem();
                    ui->tableClients->setItem(i, col, item);
                }
                item->setBackground(bgColor);
            }
        }
    }
}

// Change alert threshold - Use new function name
void ClientManager::changeAlertThreshold() {
    int newThreshold = ui->spinSeuil->value(); // Get value from spinbox
    m_alertThreshold = newThreshold; // Use new variable name
    QMessageBox::information(this, "Threshold Changed", QString("Alert threshold set to %1").arg(newThreshold));
    checkAlerts(); // Use new function name - Re-apply alert check and coloring
}

// Display an alert message - Use new function name
void ClientManager::showAlert(const QString& message) {
    QMessageBox::warning(this, "Client Alert", message);
}

// Find row index from client ID - Name was already English
int ClientManager::getRowIndexFromId(const QString& id) const {
    if (id.isEmpty()) return -1;
    for (int i = 0; i < ui->tableClients->rowCount(); ++i) {
        QTableWidgetItem *idItem = ui->tableClients->item(i, 0);
        if (idItem && idItem->text() == id) {
            return i;
        }
    }
    return -1;
}
